<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gesture Particles (No Spin)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        #video-container { position: absolute; bottom: 20px; left: 20px; width: 240px; height: 180px; z-index: 2; border: 2px solid #00ffcc; border-radius: 12px; overflow: hidden; transform: scaleX(-1); box-shadow: 0 0 15px rgba(0, 255, 204, 0.3); }
        video { width: 100%; height: 100%; object-fit: cover; }
        #ui { position: absolute; top: 20px; left: 20px; color: white; z-index: 3; pointer-events: none; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 15px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(5px); }
        h1 { margin: 0 0 10px 0; font-size: 1.8rem; text-shadow: 0 0 10px #00ffcc; letter-spacing: 1px; }
        p { font-size: 0.9rem; margin: 5px 0; opacity: 0.9; }
        .status { color: #00ffcc; font-weight: bold; text-transform: uppercase; }
        .gesture-item { margin-bottom: 4px; display: flex; align-items: center; gap: 8px; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0",
                "camera-utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
            }
        }
    </script>
</head>
<body>

    <div id="ui">
        <h1>Particle Gestures</h1>
        <p>Status: <span id="status" class="status">Initializing...</span></p>
        <p>Current: <span id="current-shape" style="color:#fff; font-weight:bold;">NONE</span></p>
        <hr style="border: 0; border-top: 1px solid rgba(255,255,255,0.2); margin: 10px 0;">
        <div class="gesture-item">ü§ü <span><b>Thumb + Index + Pinky:</b> I Love U </span></div>
        <div class="gesture-item">ü§ò <span><b>Index + Pinky:</b> Star</span></div>
        <div class="gesture-item">‚úåÔ∏è <span><b>2 Fingers:</b> DNA</span></div>
        <div class="gesture-item">‚úã <span><b>Open Hand:</b> Sphere</span></div>
        <div class="gesture-item">‚úä <span><b>Fist:</b> Cube</span></div>
    </div>

    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';

        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const s = document.createElement('script');
                s.src = src;
                s.onload = resolve;
                s.onerror = reject;
                s.crossOrigin = "anonymous";
                document.head.appendChild(s);
            });
        }

        const statusElement = document.getElementById('status');
        const shapeElement = document.getElementById('current-shape');
        const videoElement = document.getElementById('input-video');

        async function init() {
            statusElement.innerText = "Loading AI...";
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js");
            await loadScript("https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js");
            
            statusElement.innerText = "Starting Camera...";
            startApp();
        }

        init();

        function startApp() {
            // --- THREE.JS SETUP ---
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.002);
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 60;

            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // --- PARTICLES ---
            const particleCount = 15000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            const targetPositions = new Float32Array(particleCount * 3);

            for (let i = 0; i < particleCount * 3; i++) {
                positions[i] = (Math.random() - 0.5) * 150;
                colors[i] = 1.0;
                targetPositions[i] = positions[i];
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });

            const particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // --- MATH HELPERS ---
            function getSpherePoint(r) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                return { x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) };
            }

            // --- SHAPE TEMPLATES ---
            const Templates = {
                SPHERE: () => {
                    const arr = [];
                    for(let i=0; i<particleCount; i++) {
                        const p = getSpherePoint(30);
                        arr.push(p.x, p.y, p.z);
                    }
                    return arr;
                },
                CUBE: () => {
                    const arr = [];
                    const size = 35;
                    for(let i=0; i<particleCount; i++) {
                        const x = (Math.random() - 0.5) * size;
                        const y = (Math.random() - 0.5) * size;
                        const z = (Math.random() - 0.5) * size;
                        arr.push(x, y, z);
                    }
                    return arr;
                },
                DNA: () => {
                    const arr = [];
                    for(let i=0; i<particleCount; i++) {
                        const t = i * 0.05;
                        const offset = (i % 2 === 0) ? 0 : Math.PI; 
                        const r = 10;
                        const x = r * Math.cos(t * 0.1 + offset);
                        const z = r * Math.sin(t * 0.1 + offset);
                        const y = (i / particleCount) * 80 - 40;
                        arr.push(x, y, z);
                    }
                    return arr;
                },
                STAR: () => {
                    const arr = [];
                    for(let i=0; i<particleCount; i++) {
                        const r = 35 * Math.pow(Math.random(), 1/3);
                        const theta = Math.random() * Math.PI * 2;
                        const starShape = 1 + 0.5 * Math.sin(5 * theta);
                        const x = r * starShape * Math.cos(theta);
                        const y = r * starShape * Math.sin(theta);
                        const z = (Math.random() - 0.5) * 5;
                        arr.push(x, y, z);
                    }
                    return arr;
                },
                SPIRAL: () => {
                    const arr = [];
                    for(let i=0; i<particleCount; i++) {
                        const angle = i * 0.01;
                        const r = angle * 0.5;
                        const x = r * Math.cos(angle);
                        const y = r * Math.sin(angle);
                        const z = (Math.random() - 0.5) * 10;
                        arr.push(x, y, z);
                    }
                    return arr;
                },
                ILY: () => { // "I Love U" )
                    const arr = [];
                    
                    // 1. Create Canvas for Text Layout
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = 1600; 
                    canvas.height = 800;
                    
                    ctx.font = 'bold 110px "Segoe UI", Arial, sans-serif';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Draw Line 1
                    ctx.fillText("I Love U", canvas.width / 2, canvas.height / 2 - 80);
                    
                    const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
                    const textPoints = [];
                    const stride = 3; 
                    
                    for(let y = 0; y < canvas.height; y += stride) {
                        for(let x = 0; x < canvas.width; x += stride) {
                            if(imgData[(y * canvas.width + x) * 4 + 3] > 128) {
                                const px = (x - canvas.width/2) * 0.12;
                                const py = -(y - canvas.height/2) * 0.12; 
                                textPoints.push(px, py);
                            }
                        }
                    }

                    const heartParticleCount = 2500;
                    const textParticleCount = particleCount - heartParticleCount;

                    for(let i=0; i < textParticleCount; i++) {
                        if (textPoints.length > 0) {
                            const ptIndex = i % (textPoints.length / 2);
                            const tx = textPoints[ptIndex * 2];
                            const ty = textPoints[ptIndex * 2 + 1];
                            const tz = (Math.random() - 0.5) * 3;
                            arr.push(tx, ty, tz);
                        } else {
                            arr.push(0,0,0);
                        }
                    }

                    // Heart Shape (End of 2nd Line)
                    for(let i=0; i < heartParticleCount; i++) {
                        let t = Math.random() * Math.PI * 2;
                        let u = Math.random() * Math.PI;
                        const scale = 0.8;
                        const hx = (16 * Math.pow(Math.sin(t), 3) * Math.sin(u)) * scale; 
                        const hy = ((13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t)) * Math.sin(u)) * scale;
                        const hz = (6 * Math.cos(u)) * scale;
    
                    }
                    
                    return arr;
                }
            };

            // --- MEDIAPIPE LOGIC ---
            let isHandDetected = false;
            let pinchDistance = 0;
            let handCentroid = { x: 0, y: 0 };
            let targetShapeName = "SPHERE";

            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });

            function detectGesture(landmarks) {
                const tips = [8, 12, 16, 20];
                const pips = [6, 10, 14, 18];
                const fingersUp = tips.map((tip, i) => landmarks[tip].y < landmarks[pips[i]].y);
                const thumbTip = landmarks[4];
                const thumbIP = landmarks[3];
                const wrist = landmarks[0];
                const thumbUp = Math.sqrt(Math.pow(thumbTip.x-wrist.x,2)+Math.pow(thumbTip.y-wrist.y,2)) > 
                                Math.sqrt(Math.pow(thumbIP.x-wrist.x,2)+Math.pow(thumbIP.y-wrist.y,2));

                const [index, middle, ring, pinky] = fingersUp;

                if (thumbUp && index && !middle && !ring && pinky) return "ILY"; 
                if (index && !middle && !ring && pinky) return "STAR";
                if (index && middle && !ring && !pinky) return "DNA";
                if (index && !middle && !ring && !pinky) return "SPIRAL";
                if (!index && !middle && !ring && !pinky) return "CUBE";
                if (index && middle && ring && pinky) return "SPHERE";

                return "SPHERE";
            }

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    isHandDetected = true;
                    statusElement.innerText = "Tracking";
                    statusElement.style.color = "#00ff00";

                    const landmarks = results.multiHandLandmarks[0];
                    const middle = landmarks[9];
                    handCentroid.x = (middle.x - 0.5) * 2;
                    handCentroid.y = (middle.y - 0.5) * 2;

                    const dx = landmarks[8].x - landmarks[4].x;
                    const dy = landmarks[8].y - landmarks[4].y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    pinchDistance = THREE.MathUtils.clamp((dist - 0.02) * 5, 0, 1);

                    const gesture = detectGesture(landmarks);
                    updateShape(gesture);

                } else {
                    isHandDetected = false;
                    statusElement.innerText = "Show Hand";
                    statusElement.style.color = "#00ffcc";
                    if(targetShapeName !== "SPHERE") updateShape("SPHERE");
                }
            });

            const cameraUtils = new window.Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640,
                height: 480
            });
            cameraUtils.start();

            // --- ANIMATION ---
            function updateShape(name) {
                if (name !== targetShapeName) {
                    targetShapeName = name;
                    shapeElement.innerText = name;
                    
                    let newShapeData = Templates[name] ? Templates[name]() : Templates.SPHERE();

                    for (let i = 0; i < particleCount * 3; i++) {
                        targetPositions[i] = newShapeData[i];
                    }
                }
            }

            const clock = new THREE.Clock();

            function animate() {
                requestAnimationFrame(animate);
                const time = clock.getElapsedTime();
                const posArr = geometry.attributes.position.array;
                const colArr = geometry.attributes.color.array;
                
                const morphSpeed = 0.08;
                const scaleFactor = 1 + (pinchDistance * 1.5);

                // --- ROTATION LOGIC CHANGED HERE ---
                // The continuous auto-rotation line has been removed.
                
                // Hand Control Rotation (Only active when hand is present)
                if(isHandDetected) {
                    particles.rotation.x += (-handCentroid.y - particles.rotation.x) * 0.1;
                    particles.rotation.y += (-handCentroid.x - particles.rotation.y) * 0.1;
                } else {
                    // Slowly return to center if no hand
                    particles.rotation.x += (0 - particles.rotation.x) * 0.05;
                    particles.rotation.y += (0 - particles.rotation.y) * 0.05;
                }

                // Color Palettes
                let targetR, targetG, targetB;
                switch (targetShapeName) {
                    case "ILY": targetR=1.0; targetG=0.1; targetB=0.3; break; 
                    case "DNA": targetR=0.2; targetG=1.0; targetB=0.8; break; 
                    case "STAR": targetR=1.0; targetG=0.8; targetB=0.0; break; 
                    case "SPIRAL": targetR=0.5; targetG=0.0; targetB=1.0; break; 
                    case "CUBE": targetR=0.0; targetG=0.5; targetB=1.0; break; 
                    default: targetR=0.8; targetG=0.8; targetB=0.8; 
                }

                targetR += pinchDistance; 
                targetG -= pinchDistance * 0.5; 
                targetB -= pinchDistance * 0.5;

                for (let i = 0; i < particleCount; i++) {
                    const idx = i * 3;
                    
                    posArr[idx] += (targetPositions[idx] * scaleFactor - posArr[idx]) * morphSpeed;
                    posArr[idx+1] += (targetPositions[idx+1] * scaleFactor - posArr[idx+1]) * morphSpeed;
                    posArr[idx+2] += (targetPositions[idx+2] * scaleFactor - posArr[idx+2]) * morphSpeed;

                    // Slight noise for "life"
                    posArr[idx] += Math.sin(time * 2 + posArr[idx+1] * 0.1) * 0.05;
                    posArr[idx+1] += Math.cos(time * 1.5 + posArr[idx] * 0.1) * 0.05;

                    colArr[idx] += (targetR - colArr[idx]) * 0.05;
                    colArr[idx+1] += (targetG - colArr[idx+1]) * 0.05;
                    colArr[idx+2] += (targetB - colArr[idx+2]) * 0.05;
                }

                geometry.attributes.position.needsUpdate = true;
                geometry.attributes.color.needsUpdate = true;
                renderer.render(scene, camera);
            }
            animate();
        }

        window.addEventListener('resize', () => location.reload()); 
    </script>
</body>
</html>